=head1 NAME

    Statistics::Basic - A collection of very basic statistics modules

=head1 SYNOPSIS

    use Statistics::Basic qw(:all);

These actually return objects, not numbers.  The objects will interpolate as
nicely formated numbers (using L<Number::Format>).  Or the actual number will be
returned when the object is used as a number.

    my $median = median( 1,2,3 );
    my $mean   = mean(  [1,2,3]); # array refs are ok too

    my $variance = variance( 1,2,3 );
    my $stddev   = stddev(   1,2,3 );

Although passing unblessed numbers and array refs to these functions works, it's
sometimes better to pass vector objects so the objects can reuse calculated
values.

    my $v1       = $mean->query_vector;
    my $variance = variance( $v1 );
    my $stddev   = stddev(   $v1 );

Here, the mean used by the variance and the variance used by the standard
deviation will not need to be recalculated.  Now consider these two
calculations.

    my $covariance  = covariance(  [1 .. 3], [1 .. 3] );
    my $correlation = correlation( [1 .. 3], [1 .. 3] );

The covariance above would need to be recalculated by the correlation when these
functions are called this way.  But, if we instead built vectors first, that
wouldn't happen:

    # $v1 is defined above
    my $v2  = vector(1,2,3);
    my $cov = covariance(  $v1, $v2 );
    my $cor = correlation( $v1, $v2 );

Now C<$cor> can reuse the variance calculated in C<$cov>.

All of the functions above return objects that interpolate or evaluate as a
single string or as a number.  L<Statistics::Basic::LeastSquareFit> and
L<Statistics::Basic::Mode> are different:

    my $unimodal   = mode(1,2,3,3);
    my $multimodal = mode(1,2,3);

    print "The modes are: $unimodal and $multimodal.\n";
    print "The first is multimodal... " if $unimodal->is_multimodal;
    print "The second is multimodal.\n" if $multimodal->is_multimodal;

In the first case, C<$unimodal> will interpolate as a string B<and> function
correctly as a number.  However, in the second case, trying to use
C<$multimodal> as a number will C<croak> an error -- it still interpolates fine
though.

    my $lsf = leastsquarefit($v1, $v2);

This C<$lsf> will interpolate fine, showing C<"alpha: $alpha, beta: $beta">, but
it will C<croak> if you try to use the object as a number.

    my $v3             = $multimodal->query;
    my ($alpha, $beta) = $lsf->query;
    my $average        = $mean->query;

All of the objects allow you to explicitly query, if you're not in the mood to
use L<overload>.

    my @answers = (
        $mode->query,
        $median->query,
        $stddev->query,
    );

=head1 SHORTCUTS

The following shortcut functions can be used in place of calling the module's
C<new()> method directly.

They all take either array refs B<or> lists as arguments, with the exception of
the shortcuts that need two vectors to process (e.g.
L<Statistics::Basic::Correlation>).

=over

=item C<vector()>

Arguments to C<vector()> can be any of: an array ref, a list of numbers, or a
blessed vector object.  If passed a blessed vector object, vector will just
return the vector passed in.

=item C<mean()> C<average()> C<avg()>

You can choose to call C<mean()> as C<average()> or C<avg()>.  Arguments can be
any of: an array ref, a list of numbers, or a blessed vector object.

=item C<median()>

Arguments can be any of: an array ref, a list of numbers, or a blessed vector
object.

=item C<mode()>

Arguments can be any of: an array ref, a list of numbers, or a blessed vector
object.

=item C<variance()> C<var()>

You can choose to call C<variance()> as C<var()>.  Arguments can be any of: an
array ref, a list of numbers, or a blessed vector object.  If you will also be
calculating the mean of the same list of numbers it's recommended to do this:

    my $vec  = vector(1,2,3);
    my $mean = mean($vec);
    my $var  = variance($vec);

This would also work:

    my $mean = mean(1,2,3);
    my $var  = variance($mean->query_vector);

This will calculate the same mean twice:

    my $mean = mean(1,2,3);
    my $var  = variance(1,2,3);

If you really only need the variance, ignore the above and this is fine:

    my $variance = variance(1,2,3,4,5);

=item C<stddev()>

Arguments can be any of: an array ref, a list of numbers, or a blessed vector
object.  Pass a vector object to C<stddev()> to avoid recalculating the variance
and mean if applicable (see C<variance()>).

=item C<covariance()> C<cov()>

Arguments to C<covariance()> or C<cov()> must be array ref or vector objects.
There must be precisely two arguments (or none, setting the vectors to two empty
ones), and they must be the same length.

=item C<correlation()> C<cor()> C<corr()>

Arguments to C<correlation()> or C<cor()>/C<corr()> must be array ref or vector
objects.  There must be precisely two arguments (or none, setting the vectors to
two empty ones), and they must be the same length.

=item C<leastsquarefit()> C<LSF()> C<lsf()>

Arguments to C<leastsquarefit()> or C<lsf()>/C<LSF()> must be array ref or
vector objects.  There must be precisely two arguments (or none, setting the
vectors to two empty ones), and they must be the same length.

=item C<computed()>

Argument must be a blessed vector object.

=back

=head1 COMPUTED VECTORS

Sometimes it will be handy to have a vector computed from another (or at least
that updates based on the first).  Consider the case of outliers:

    my @a = ( (1,2,3) x 7, 15 );
    my @b = ( (1,2,3) x 7 );

    my $v1 = vector(@a);
    my $v2 = vector(@b);
    my $v3 = computed($v1);
       $v3->set_filter(sub {
           my $m = mean($v1);
           my $s = stddev($v1);

           grep { abs($_-$m) <= $s } @_;
       });

This filter sets C<$v3> to always be equal to C<$v1> such that all the elements
that differ from the mean by more than a standard deviation are removed.  As
such, C<"$v2" eq "$v3"> since C<15> is clearly an outlier by inspection.

=head2 OUTLIERS

=head1 REUSE DETAILS

Most of the objects have a variety of query functions that allow you to extract
the objects used within.  Although, the objects are smart enough to prevent
needless duplication.  That is, the following would test would pass:

    use Statistics::Basic qw(:all);

    my $v1 = vector(1,2,3,4,5);
    my $v2 = vector($v1);
    my $sd = stddev( $v1 );
    my $v3 = $sd->query_vector;
    my $m1 = mean( $v1 );
    my $m2 = $sd->query_mean;
    my $m3 = Statistics::Basic::Mean->new( $v1 );
    my $v4 = $m3->query_vector;

    use Scalar::Util qw(refaddr);
    use Test; plan tests => 5;

    ok( refaddr($v1), refaddr($v2) );
    ok( refaddr($v2), refaddr($v3) );
    ok( refaddr($m1), refaddr($m2) );
    ok( refaddr($m2), refaddr($m3) );
    ok( refaddr($v3), refaddr($v4) );

    # this is t/54_* in the distribution

Also, note that the mean is only calculated once even though we've calculated a
variance and a standard deviation above.

Suppose you'd like a copy of the L<Statistics::Basic::Variance> object that the
L<Statistics::Basic::StdDev> object is using.  All of the objects within should
be accessible with query functions as follows.

=head1 QUERY FUNCTIONS

=over

=item C<query()>

This method exists in all of the objects.  L<Statistics::Basic::LeastSquareFit>
is the only one that returns two values (alpha and beta) as a list.  All of the
other C<query()> methods return a single number, the number the module purports
to calculate.

=item C<query_mean()>

Returns the L<Statistics::Basic::Mean> object used by
L<Statistics::Basic::Variance> and L<Statistics::Basic::StdDev>.

=item C<query_mean1()>

Returns the first L<Statistics::Basic::Mean> object used by
L<Statistics::Basic::Covariance>, L<Statistics::Basic::Correlation> and
L<Statistics::Basic::LeastSquareFit>.

=item C<query_mean2()>

Returns the second L<Statistics::Basic::Mean> object used by
L<Statistics::Basic::Covariance>, L<Statistics::Basic::Correlation> and
L<Statistics::Basic::LeastSquareFit>.

=item C<query_covariance()>

Returns the L<Statistics::Basic::Covariance> object used by
L<Statistics::Basic::Correlation> and L<Statistics::Basic::LeastSquareFit>.

=item C<query_variance()>

Returns the L<Statistics::Basic::Variance> object used by
L<Statistics::Basic::StdDev>.

=item C<query_variance1()>

Returns the first L<Statistics::Basic::Variance> object used by
L<Statistics::Basic::LeastSquareFit>.

=item C<query_variance2()>

Returns the first L<Statistics::Basic::Variance> object used by
L<Statistics::Basic::LeastSquareFit>.

=item C<query_vector()>

Returns the L<Statistics::Basic::Vector> object used by any of the single vector
modules.

=item C<query_vector1()>

Returns the first L<Statistics::Basic::Vector> object used by any of the two
vector modules.

=item C<query_vector2()>

Returns the second L<Statistics::Basic::Vector> object used by any of the two
vector modules.

=item C<is_multimodal()>

L<Statistics::Basic::Mode> objects sometimes return L<Statistics::Basic::Vector>
objects instead of numbers.  When C<is_multimodal()> is true, the mode is a
vector, not a scalar.

=item C<y_given_x()>

L<Statistics::Basic::LeastSquareFit> is meant for finding a line of best fit.
This function can be used to find the C<y> for a given C<x> based on the
calculated C<$beta> (slope) and C<$alpha> (y-offset).

=item C<x_given_y()>

L<Statistics::Basic::LeastSquareFit> is meant for finding a line of best fit.
This function can be used to find the C<x> for a given C<y> based on the
calculated C<$beta> (slope) and C<$alpha> (y-offset).

This function can produce divide-by-zero errors since it must divide by the
slope to find the C<x> value.  (The slope should rarely be zero though, that's a
vertical line and would represent very odd data points.)

=back

=head1 INSERT and SET FUNCTIONS

These objects are all intended to be useful while processing long columns of
data, like data you'd find in a database.

=over

=item C<insert()>

Vectors know how to stay the same size and accept new elements.

    my $v1 = vector(1,2,3); # a 3 touple
       $v1->insert(4); # still a 3 touple

    print "$v1\n"; # prints: [2, 3, 4]

    $v1->insert(7); # still a 3 touple
    print "$v1\n"; # prints: [3, 4, 7]

All of the other L<Statistics::Basic> modules have this function too.  The
modules that track two vectors will need two arguments to insert though.

    my $mean = mean([1,2,3]);
       $mean->insert(4);

    print "mean: $mean\n"; # prints 3 ... (2+3+4)/3

    my $correlation = correlation($mean->query_vector,
        $mean->query_vector->copy);

    print "correlation: $correlation\n"; # 1

    $correlation->insert(3,4);
    print "correlation: $correlation\n"; # 0.5

Also, note that the underlying vectors keep track of recalculating
automatically.

    my $v = vector(1,2,3);
    my $m = mean($v);
    my $s = stddev($v);

The mean has not been calculated yet.

    print "$s; $m\n"; # 0.82; 2

The mean has been calculated once (even though the stddev uses it).

    $v->insert(4); print "$s; $m\n"; 0.82; 3
    $m->insert(5); print "$s; $m\n"; 0.82; 4
    $s->insert(6); print "$s; $m\n"; 0.82; 5

The mean has been calculated thrice more and only thrice more.

=item C<ginsert()>

You can grow the vectors instead of sliding them FIFO style.

    my $v = vector(1,2,3);
    my $m = mean($v);
    my $s = stddev($v);

    $v->ginsert(4); print "$s; $m\n"; 1.12; 2.5
    $m->ginsert(5); print "$s; $m\n"; 1.41; 3
    $s->ginsert(6); print "$s; $m\n"; 1.71; 1.71

Of course, with a correlation, or a covariance, it'd look more like this:

    my $c = correlation([1,2,3], [3,4,5]);
       $c->ginsert(7,7);

    print "c=$c\n"; # c=0.98

=item C<set_vector()>

This allows you to set the vector to a known state.  It takes either array ref
or vector objects.

    my $v1 = vector(1,2,3);
    my $v2 = $v1->copy;
       $v2->set_vector([4,5,6]);

    my $m = mean();

    $m->set_vector([1,2,3]);
    $m->set_vector($v2);

    my $c = correlation();

    $c->set_vector($v1,$v2);
    $c->set_vector([1,2,3], [4,5,6]);

=item C<set_size()>

This sets the size of the vector.  When the vector is made bigger, the vector is
filled to the new length with leading zeros (i.e., they are the first to be
kicked out after new C<insert()>s.

    my $v = vector(1,2,3);
       $v->set_size(7);

    print "$v\n"; # [0, 0, 0, 0, 1, 2, 3]

    my $m = mean();
       $m->set_size(7);

    print "", $m->query_vector, "\n";
     # [0, 0, 0, 0, 0, 0, 0]

    my $c = correlation([3],[3]);
       $c->set_size(7);

    print "", $c->query_vector1, "\n";
    print "", $c->query_vector2, "\n";
     # [0, 0, 0, 0, 0, 0, 3]
     # [0, 0, 0, 0, 0, 0, 3]

=back

=head1 ENVIRONMENT VARIABLES

=over

=item C<$ENV{DEBUG}>

Try setting C<$ENV{DEBUG}=1>; or C<$ENV{DEBUG}=2>; to see the internals.

Also, from your bash prompt you can C<'DEBUG=1 perl ./myprog.pl'> to
enable debugging dynamically.

=item C<$ENV{UNBIAS}>

This module uses the sum(X - mean(X))/N definition of variance.
If you wish to use the unbiased, sum(X-mean(X)/(N-1) definition, then 
set the C<$ENV{UNBIAS}=1>;

This feature was requested by Robert McGehee <xxxxxxxx@wso.williams.edu>.

=item C<$ENV{IRES}>

C<$ENV{IRES}>, which defaults to 2, is passed to L<Number::Format> as the second
argument to C<format_number> during string interpolation (see: L<overload>).

=item C<$ENV{TOLER}>

When set C<$ENV{TOLER}> (which by default doesn't exist in the environment
hash), this instructs the stats objects to test true when I<within> some
tolerable range, pretty much like this:

    sub is_equal {
        return abs($_[0]-$_[1])<$ENV{TOLER} if exists($ENV{TOLER});
        return $_[0] ==$_[1]
    }

=back

=head1 AUTHOR

Paul Miller <jettero@cpan.org>

I am using this software in my own projects...  If you find bugs, please
please please let me know. :) Actually, let me know if you find it handy at
all.  Half the fun of releasing this stuff is knowing that people use it.

=head1 COPYRIGHT

LGPL!  I included a lgpl-2.1.txt.gz for your reading enjoyment.

=head1 SEE ALSO

perl(1), L<Number::Format>, L<overload>
